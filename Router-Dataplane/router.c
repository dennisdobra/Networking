#include "queue.h"
#include "lib.h"
#include "protocols.h"
#include <arpa/inet.h>
#include <string.h>

/* Routing table */
struct route_table_entry *rtable;
int rtable_len;

/* MAC table */
struct arp_table_entry *arp_table;
int arp_table_len;

/* Queue for packets that need ARP reply */
struct queue *waiting_packets;

/* Queue for waiting packets lengths */
struct queue *waiting_lengths;

/*
 Returns a pointer (eg. &rtable[i]) to the best matching route, or NULL if there
 is no matching route.
*/
struct route_table_entry *get_best_route(uint32_t ip_dest) {
	/* LPM algorithm */
	struct route_table_entry *match = NULL;

	for (int i = 0; i < rtable_len; i++) {
		if (rtable[i].prefix == (ip_dest & rtable[i].mask)) {
			if (match == NULL) {
				match = &rtable[i];
			}
			/* find the most specific route */
			if (ntohl(rtable[i].mask) > ntohl(match->mask))
				match = &rtable[i];
		}
	}
	return match;
}

/* same function as find_best_route(), but implemented with binary search
   call with find_best_route_binary(0, rtable_len - 1, <destination_ip>) */
struct route_table_entry *get_best_route_binary(int l, int r, uint32_t ip_dest) {
	struct route_table_entry *match = NULL;

    while (l <= r) {
        int mid = (l + r) / 2;

        if ((ip_dest & rtable[mid].mask) == rtable[mid].prefix) {
			if (match == NULL)
				match = &rtable[mid];
			if (ntohl(rtable[mid].mask) > ntohl(match->mask))
				match = &rtable[mid];
		}
		if (ntohl(rtable[mid].prefix) < (ntohl(ip_dest))) {
			l = mid + 1;
		} else if (ntohl(rtable[mid].prefix) > (ntohl(ip_dest))) {
			r = mid - 1;
		}
    }

    return match;
}

/* 
	Returns a pointer (eg. &arp_table[i]) to the arp_table_entry, with the MAC address
	for the give_ip, or NULL if there are no matches
*/
struct arp_table_entry *get_arp_entry(uint32_t given_ip) {
	for (int i = 0; i < arp_table_len; i++) {
		if (arp_table[i].ip == given_ip) {
			return &arp_table[i];
		}
	}
	return NULL;
}

/* comparator for sorting routing table */
int comparator(const void *a, const void *b) {
	const struct route_table_entry *entry_a = (const struct route_table_entry *)a;
	const struct route_table_entry *entry_b = (const struct route_table_entry *)b;

	if (ntohl(entry_a->prefix) > ntohl(entry_b->prefix)) {
		return 1;
	} else if (ntohl(entry_a->prefix) == ntohl(entry_b->prefix)) {
		if (ntohl(entry_a->mask) > ntohl(entry_b->mask)) {
			return 1;
		}
	}

	return -1;
}

void host_unreachable_or_time_exceeded(char *recv_packet, uint8_t interface, uint32_t host_ip, uint8_t type) {
	/* If a packet is dropped by the router, an ICMP message is generated by the router
	   and it is sent to received packet's sender */
	size_t icmp_packet_len = sizeof(struct ether_header) + 2 * sizeof(struct iphdr) + sizeof(struct icmphdr) + 8;
	char *icmp_packet = malloc(icmp_packet_len);

	/* ETHERNET header for the new packet */
	struct ether_header *eth_hdr = (struct ether_header *)icmp_packet;
	memcpy(icmp_packet, recv_packet, sizeof(struct ether_header));
	memcpy(eth_hdr->ether_dhost, eth_hdr->ether_shost, 6); 	// dest MAC is sender's src MAC
	get_interface_mac(interface, eth_hdr->ether_shost);		// src MAC is router's MAC address for 'interface'

	/* first IPv4 header for the new packet */
	struct iphdr *ip_hdr1 = (struct iphdr *)(icmp_packet + sizeof(struct ether_header));
	ip_hdr1->version = 4;
	ip_hdr1->ihl = 5;
	ip_hdr1->tos = 0;
	ip_hdr1->tot_len = htons(2 * sizeof(struct iphdr) + sizeof(struct icmphdr) + 8);
	ip_hdr1->id = htons(1);
	ip_hdr1->frag_off = htons(0);
	ip_hdr1->ttl = 100;
	ip_hdr1->protocol = 1;
	ip_hdr1->check = 0;
	ip_hdr1->check = htons(checksum((uint16_t *)ip_hdr1, sizeof(struct iphdr)));
	ip_hdr1->saddr = inet_addr(get_interface_ip(interface));
	ip_hdr1->daddr = host_ip;

	/* ICMP header for the new packet */
	struct icmphdr *icmp_hdr = (struct icmphdr *)(icmp_packet + sizeof(struct ether_header) + sizeof(struct iphdr));
	icmp_hdr->type = type;
	icmp_hdr->code = 0;
	icmp_hdr->checksum = 0;
	icmp_hdr->checksum = htons(checksum((uint16_t *)icmp_hdr, sizeof(struct icmphdr) + sizeof(struct iphdr) + 8));

	/* second IPv4 header -> copy of the IPv4 header from the recv_packet */
	struct iphdr *ip_hdr2 = (struct iphdr *)(icmp_packet + sizeof(struct ether_header) + sizeof(struct iphdr) + sizeof(struct icmphdr));
	memcpy(ip_hdr2, recv_packet + sizeof(struct ether_header), sizeof(struct iphdr));

	/* payload for the new packet -> first 8 bytes of data from recv_packet */
	char *recv_packet_payload = (char *)(recv_packet + sizeof(struct ether_header) + sizeof(struct iphdr));
	uint8_t *icmp_packet_payload = (uint8_t *)(icmp_packet + sizeof(struct ether_header) + 2 * sizeof(struct iphdr) + sizeof(struct icmphdr));
	memcpy(icmp_packet_payload, recv_packet_payload, 8);

	/* send the ICMP message to the host */
	send_to_link(interface, icmp_packet, icmp_packet_len);
}

void send_icmp_echo_reply(char *recv_packet, size_t packet_len, uint8_t interface, uint32_t host_ip, uint8_t type) {
	/* in this function the received packet is modified */

	/* modify the ETHERNET addresses */
	struct ether_header *eth_hdr = (struct ether_header *)recv_packet;
	memcpy(eth_hdr->ether_dhost, eth_hdr->ether_shost, 6);
	get_interface_mac(interface, eth_hdr->ether_shost);

	/* modify first IPv4 header - only IP addresses */
	struct iphdr *ip_hdr = (struct iphdr *)(recv_packet + sizeof(struct ether_header));
	ip_hdr->saddr = inet_addr(get_interface_ip(interface));
	ip_hdr->daddr = host_ip;

	/* modify ICMP header */
	struct icmphdr *icmp_hdr = (struct icmphdr *)(recv_packet + sizeof(struct ether_header) + sizeof(struct iphdr));
	icmp_hdr->type = type;
	// OBS: ICMP header 'type' field modified => we need to recalculate checksum for ICMP header
	size_t icmp_hdr_len = packet_len - sizeof(struct ether_header) - sizeof(struct iphdr);
	icmp_hdr->checksum = 0;
	icmp_hdr->checksum = htons(checksum((uint16_t *)icmp_hdr, icmp_hdr_len));

	/* send the ICMP Echo Reply message to the host */
	send_to_link(interface, recv_packet, packet_len);
}

/* router generates an ARP packet in order to ask for the MAC address of the machine
   which has the IPv4 address of the next hop (IPv4 address is known already)
   
   OBS: get_mac_interface() function returns the MAC address of one of the router's interfaces. As one
   router has multiple interfaces/ports => it will have multiple MAC addresses =-> this is why i use
   best_router->interface in this function. In the 2 ICMP functions above the message was sent back to
   the host from the same interface it has received on, so i would just use 'interface', but now the
   packet goes in another direction */
void send_arp_request(struct route_table_entry *best_route) {
	size_t arp_packet_len = sizeof(struct ether_header) + sizeof(struct arp_header);
	char *arp_packet = malloc(arp_packet_len);

	/* ETHERNET header */
	struct ether_header *eth_hdr = (struct ether_header *)arp_packet;
	eth_hdr->ether_type = htons(ETHERTYPE_ARP);
	// source MAC is the MAC of the interface/port that is used to reach next hop
	get_interface_mac(best_route->interface, eth_hdr->ether_shost);
	hwaddr_aton("ff:ff:ff:ff:ff:ff", eth_hdr->ether_dhost);

	/* ARP header */
	struct arp_header *arp_hdr = (struct arp_header *)(arp_packet + sizeof(struct ether_header));
	arp_hdr->htype = htons(1);
	arp_hdr->ptype = htons(ETHERTYPE_IP);
	arp_hdr->hlen = 6;
	arp_hdr->plen = 4;
	arp_hdr->op = htons(1);

	get_interface_mac(best_route->interface, arp_hdr->sha); 			  	// source MAC
	uint32_t src_ip = inet_addr(get_interface_ip(best_route->interface)); 	// source IP
	memcpy(&arp_hdr->spa, &src_ip, sizeof(uint32_t));
	char *dest_mac = "00:00:00:00:00:00";									// destination MAC
	hwaddr_aton(dest_mac, arp_hdr->tha);
	memcpy(&arp_hdr->tpa, &best_route->next_hop, sizeof(uint32_t));			// destination IP

	/* send ARP request packet */
	send_to_link(best_route->interface, arp_packet, arp_packet_len);
}


void send_arp_reply(char *recv_packet, size_t recv_packet_len, uint8_t interface) {
	/* modify the ARP request received packet */

	/* modify ETHERNET header */
	struct ether_header *eth_hdr = (struct ether_header *)recv_packet;
	memcpy(eth_hdr->ether_dhost, eth_hdr->ether_shost, 6);
	get_interface_mac(interface, eth_hdr->ether_shost);

	/* modify ARP header */
	struct arp_header *arp_hdr = (struct arp_header *)(recv_packet + sizeof(struct ether_header));
	arp_hdr->op = htons(2); 	// ARP reply
	memcpy(&arp_hdr->tha, &arp_hdr->sha, 6);					// target MAC
	memcpy(&arp_hdr->tpa, &arp_hdr->spa, sizeof(uint32_t));		// target IP
	get_interface_mac(interface, arp_hdr->sha); 				// sender MAC
	uint32_t src_ip = inet_addr(get_interface_ip(interface));
	memcpy(&arp_hdr->spa, &src_ip, sizeof(uint32_t)); 			// sender IP

	/* send ARP reply packet */
	send_to_link(interface, recv_packet, recv_packet_len);
}


void receive_arp_reply(char *recv_packet, uint8_t interface) {
	struct arp_header *arp_hdr = (struct arp_header *)(recv_packet + sizeof(struct ether_header));

	/* I will add a new entry in the ARP routing table */
	struct arp_table_entry *new_entry = malloc(sizeof(struct arp_table_entry));
	new_entry->ip = arp_hdr->spa;
	memcpy(new_entry->mac, arp_hdr->sha, 6);
	arp_table[arp_table_len] = *new_entry;
	arp_table_len++;

	/* check waiting_packets queue to see if any packet can be sent */
	while (!queue_empty(waiting_packets)) {
		/* dequeue first packet and its length */
		char *deq_packet = queue_deq(waiting_packets);
		size_t *deq_length = (size_t *)queue_deq(waiting_lengths);

		/* the dequeued packet has an ETHERNET header and an IPv4 header */
		struct ether_header *eth_hdr = (struct ether_header *)deq_packet;
		struct iphdr *ip_hdr = (struct iphdr *)(deq_packet + sizeof(struct ether_header));

		/* now, I'm not sure that the ARP reply message is for the first packet in queue =>
		   I will see if the dequeued packet's next hop's IP is the same as source IP in the
		   ARP reply message  */

		/* find next hop's IP address for the dequeued packet */
		struct route_table_entry *best_route_for_deq_packet = get_best_route(ip_hdr->daddr);
		/* find next hop's MAC address */
		struct arp_table_entry *destination_entry = get_arp_entry(best_route_for_deq_packet->next_hop);

		/* modify ETHERNET header for dequeued packet */
		memcpy(eth_hdr->ether_dhost, destination_entry->mac, 6);
		get_interface_mac(best_route_for_deq_packet->interface, eth_hdr->ether_shost);

		/* check if the ARP reply is for the dequeued packet */
		if (new_entry->ip == best_route_for_deq_packet->next_hop) {
			send_to_link(best_route_for_deq_packet->interface, deq_packet, *deq_length);
		} else {
			/* put it back in the queue to wait for another ARP reply */
			queue_enq(waiting_packets, deq_packet);
			queue_enq(waiting_lengths, (void *)deq_length);
			break;
		}
	}
}


int main(int argc, char *argv[])
{
	char packet[MAX_PACKET_LEN];

	// Do not modify this line
	init(argc - 2, argv + 2);

	/* Allocate MAC and route tables */
	rtable = malloc(sizeof(struct route_table_entry) * 80000);
	DIE(rtable == NULL, "memory");

	arp_table = malloc(sizeof(struct arp_table_entry) * 100);
	DIE(arp_table == NULL, "memory");

	/* read the static routing table and the ARP table */
	rtable_len = read_rtable(argv[1], rtable);

	/* sort the routing table */
	qsort(rtable, rtable_len, sizeof(struct route_table_entry), comparator);

	/* Create waiting queue for packets and queue for waiting lengths */
	waiting_packets = queue_create();
	waiting_lengths = queue_create();

	/* Note that packets received are in network order,
   	   any header field which has more than 1 byte will need to be converted to
   	   host order. For example, ntohs(eth_hdr->ether_type). The oposite is needed when
       sending a packet on the link, */

	while (1) {

		int interface;
		size_t packet_len;

		/* returns the interface it has received the data from */
		interface = recv_from_any_link(packet, &packet_len);
		DIE(interface < 0, "recv_from_any_links");

		/* The router has received a packet */

		/* Extract the Ethernet header from the packet. Since protocols are
		 * stacked, the first header is the ethernet header, the next header is
		 * at m.payload + sizeof(struct ether_header) */
		struct ether_header *eth_hdr = (struct ether_header *) packet;
		struct iphdr *ip_hdr = (struct iphdr *)(packet + sizeof(struct ether_header));

		/* check the type of packet received */
		if (eth_hdr->ether_type == ntohs(ETHERTYPE_IP)) {
			/* Check if the router has received an ICMP Echo Request message for himself */
			if (ip_hdr->protocol == 1) {
				/* It means there is an ICMP message */
				struct icmphdr *icmp_hdr = (struct icmphdr *)(packet + sizeof(struct ether_header) + sizeof(struct iphdr));
				if (icmp_hdr->type == 8 && ip_hdr->daddr == inet_addr(get_interface_ip(interface))) {
					/* An Echo Request ICMP packet has received for the router */
					send_icmp_echo_reply(packet, packet_len, interface, ip_hdr->saddr, 0);
					continue;
				}
			}
			
			/* check the ip_hdr integrity */
			uint64_t aux = ip_hdr->check;
			ip_hdr->check = 0;
			if (checksum((uint16_t *)ip_hdr, sizeof(struct iphdr)) != ntohs(aux)) {
				/* ignore the packet */
				continue;
			}

			/* the router searches the destination IP address of the received packet in the routing table
			   to determine the next hop and also the interface on which the packet should be sent. If it
			   doesn't find any match, the packet is dropped and "Destination unreachable" msg is sent back */
			struct route_table_entry *best_route = get_best_route(ip_hdr->daddr);
			if (best_route == NULL) {
				/* send host_unreachable ICMP msg, type = 3 */
				host_unreachable_or_time_exceeded(packet, interface, ip_hdr->saddr, 3);
				continue;
			}

			/* Check TTL > 1 */
			if (ip_hdr->ttl > 1) {
				ip_hdr->ttl--;
			} else {
				/* send time_exceeded ICMP msg, type = 11 */
				host_unreachable_or_time_exceeded(packet, interface, ip_hdr->saddr, 11);
				continue;
			}

			/* Update checksum after TTL changed */
			ip_hdr->check = 0;
			ip_hdr->check = htons(checksum((uint16_t *)ip_hdr, sizeof(struct iphdr)));

			/* Update Ethernet addresses */

			// source address is the router's interface MAC address on which
			// it sends the packet for the next hop
			uint8_t source_mac[6];
			get_interface_mac(best_route->interface, source_mac);

			// destination address will be next hop's MAC adress =>
			// router tries to find the MAC address for next hop
			struct arp_table_entry *destination_entry = get_arp_entry(best_route->next_hop);
			// check if destination_mac == NULL => no match was found => ARP request
			if (destination_entry == NULL) {
				/* No next hop was found in the ARP cache => the router needs to generate an
				   ARP request message and wait for a response. The initial packet 'packet'
				   which was received is added in a queue in order to be sent later, after
				   receiving ARP reply response. */
				
				// de ce fac cate o copie?
				char *duplicate_packet = malloc(packet_len);
				memcpy(duplicate_packet, packet, packet_len);
				queue_enq(waiting_packets, duplicate_packet);

				size_t *duplicate_length = malloc(sizeof(size_t));
				memcpy(duplicate_length, &packet_len, sizeof(size_t));
				queue_enq(waiting_lengths, duplicate_length);

				send_arp_request(best_route);
				continue;
			}

			// Update Ethernet addresses on the packet
			for (int i = 0; i < 6; i++) {
				eth_hdr->ether_shost[i] = source_mac[i];
				eth_hdr->ether_dhost[i] = destination_entry->mac[i];
			}

			/* sending new packet on the next hop's interface */
			send_to_link(best_route->interface, packet, packet_len);

		} else if (eth_hdr->ether_type == ntohs(ETHERTYPE_ARP)) {
			/* the router has received a type of ARP packet */

			struct arp_header *arp_hdr = (struct arp_header *)(packet + sizeof(struct ether_header));
			
			if (arp_hdr->op == htons(1)) {
				/* router has received an ARP request packet => send ARP reply response */
				send_arp_reply(packet, packet_len, interface);
			} else if (arp_hdr->op == htons(2)) {
				/* router received ARP reply response */
				receive_arp_reply(packet, interface);
			}
		}
	}
}